directive @isPublished(to: String!) on FIELD_DEFINITION | OBJECT
directive @subscribe on FIELD_DEFINITION
directive @publish(to: String!) on FIELD_DEFINITION | OBJECT

type User @isAuthenticated {
id: ID!
firstName: String!
lastName: String!
}

type Task {
    id: ID!
    content: String!
    column: Column @relation(name: "BELONGS_TO", direction: "OUT")
}

type Column {
    id: ID!
    title: String!
    tasks: [Task] @relation(name: "BELONGS_TO", direction: "IN")
    table: Table @relation(name: "BELONGS_TO", direction: "OUT")
    taskIds: [ID]
}

type Table {
    id: ID!
    title: String!
    columns: [Column] @relation(name: "BELONGS_TO", direction: "IN")
    columnOrder: [ID]
}

type Subscription {
    taskAdded: Task
}

type Mutation {
    addTask(taskContent: String!, columnId: ID!): Task
    @cypher (
        statement: "CREATE (t:Task { id: randomUUID(), content: $taskContent }) with t MATCH(c:Column {id: $columnId}) CREATE(c)<-[:BELONGS_TO]-(t) set c.taskIds = c.taskIds + t.id return t"
    )

    swapTask(fromColumnId: ID!, toColumnId: ID!, taskId: ID!): Column
    @cypher (
        statement:
        "MATCH (c1:Column {id: $fromColumnId})<-[r]-(t:Task {id: $taskId}) SET c1.taskIds = [x IN c1.taskIds where x <> $taskId] DELETE r WITH t MATCH (c2:Column {id: $toColumnId}) CREATE (c2)<-[:BELONGS_TO]-(t) SET c2.taskIds = c2.taskIds + t.id RETURN c2"
    )

    updateTaskOrder(oldId: ID!, newId: ID!): Task
    @cypher (
        statement:
        "MATCH (c1:Column {id: $fromColumnId})<-[r]-(t:Task {id: $taskId}) SET c1.taskIds = [x IN c1.taskIds where x <> $taskId] DELETE r WITH t, table MATCH (c2:Column {id: $toColumnId}) CREATE (c2)<-[:BELONGS_TO]-(t) SET c2.taskIds = c2.taskIds + t.id RETURN c2"
    )
}
