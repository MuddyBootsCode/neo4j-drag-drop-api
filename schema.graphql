directive @subscribe on FIELD_DEFINITION
directive @publish(to: String!) on FIELD_DEFINITION | OBJECT
scalar JSON

type User {
    id: ID!
    firstName: String!
    lastName: String!
    mailingAddress: String
    streetAddress: String
    city: String
    zipcode: String
    phoneNumber1: String
    phoneNumber2: String
    dateOfBirth: String
    email: String
    currentPassport: String
    multiLingual: String
    cldrTrained: String
    partnerAgency: String
    cclsCertification: String
    yearsExperience: String
    shirtSize: String
    preferredAirport: Airport @relation(name: "AIRPORT", direction: "OUT")
    specialSkills: String
    workingPreschoolChildren: String
    workingSchoolAgeChildren: String
    workingAdolescents: String
    workingSpecialNeeds: String
    workingParents: String
    usingTech: String
    workingHighStress: String
    workingPhysical: String
    griefAndLoss: String
    workingTrauma: String
    workingCopingTechniques: String
    workingNaturalDisasters: String
    workingManMadeDisasters: String
    adminNotes: String
    speaks: [Speaks]
    livesIn: State @relation(name: "LIVES_IN", direction: "OUT")
}

type State {
    name: String
    abbreviation: String
    livesIn: User @relation(name: "LIVES_IN", direction: "IN")
}

type Airport {
    code: String
    lat: String
    lon: String
    name: String
    city: String
    state: String
    country: String
    woeid: String
    tz: String
    type: String
    email: String
    url: String
    preferrdedBy: User @relation(name: "AIRPORT", direction: "IN")
}

type Language {
    name: String
    spokenBy: [Speaks]
}

type Task {
    id: ID!
    content: String!
    column: Column @relation(name: "BELONGS_TO", direction: "OUT")
}

type Column {
    id: ID!
    title: String!
    tasks: [Task] @relation(name: "BELONGS_TO", direction: "IN")
    table: Table @relation(name: "BELONGS_TO", direction: "OUT")
    taskIds: [ID]
}

type Table {
    id: ID!
    title: String!
    columns: [Column] @relation(name: "BELONGS_TO", direction: "IN")
    columnOrder: [ID]
}

type Speaks @relation(name: "SPEAKS") {
    id: ID
    from: User
    to: Language
    level: String
}

type Subscription {
    taskAdded: Task @subscribe
}

type Mutation {
    addTask(taskContent: String!, columnId: ID!, taskId: ID!): Task @publish(to: "taskAdded")
    @cypher (
        statement: "CREATE (t:Task { id: $taskId, content: $taskContent }) with t MATCH(c:Column {id: $columnId}) CREATE(c)<-[:BELONGS_TO]-(t) set c.taskIds = c.taskIds + t.id return t"
    )

    addUserState(userId: ID!, stateName: String!, stateAbbreviation: String!): User
    @cypher (
        statement: "MATCH (u:User {id: $userId}) MERGE (s:State {name: $stateName, abbreviation: $stateAbbreviation}) MERGE (u)-[:LIVES_IN]->(s) return u"
    )

    addUserLanguages(userId: ID!, languageName: String!, level: String!): User
    @cypher (
        statement: "MATCH (u:User {id: $userId}) MERGE (l:Language {name: $languageName}) MERGE (u)-[:SPEAKS {level: $level}]->(l) return u"
    )
}
